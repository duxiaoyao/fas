import asyncio
import datetime as dt
import logging
import os
from pathlib import Path
from typing import Dict

from dynaconf import settings
from invoke import task, Collection

from fas.environment import ENV
from .client import DBClient, DBPool
from .migration import load_versions, SCRIPT_DIR, calculate_md5_hash
from .transaction import transactional

LOGGER = logging.getLogger(__name__)


@task(name='create')
def create_database_if_not_exist(c):
    """
    Create database
    """
    env = os.environ.copy()
    env['PGPASSWORD'] = c.db.owner.password
    if is_database_existed(c, env):
        LOGGER.warning(f'Cannot create database {c.db.database}: already exist')
        return
    c.run(f'''
        createdb -h {c.db.host} -p {c.db.port} -U {c.db.owner.name} {c.db.database} \
        -T template0 -E UTF-8 --locale=C.UTF-8
        ''', env=env)
    LOGGER.info(f'Created database {c.db.database}')


@task(name='drop')
def drop_database(c):
    """
    Drop database
    """
    if not (ENV.is_dev or ENV.is_test):
        raise Exception('Cannot drop database under environments other than dev or test')
    env = os.environ.copy()
    env['PGPASSWORD'] = c.db.owner.password
    if not is_database_existed(c, env):
        LOGGER.warning(f'Cannot drop database {c.db.database}: not found')
        return
    c.run(f'dropdb -h {c.db.host} -p {c.db.port} -U {c.db.owner.name} {c.db.database}', env=env)
    LOGGER.info(f'Dropped database {c.db.database}')


@task(name='migrate')
def migrate_database(c):
    """
    Migrate database
    """
    create_database_if_not_exist(c)

    async def _migrate_database():
        async with DBPool(**settings.DB) as pool:
            async with pool.acquire() as db:
                await create_database_migration_table_if_not_exist(db)
                current_version = await db.get_scalar(
                    'SELECT to_version FROM database_migration ORDER BY id DESC LIMIT 1') or 0
            new_versions = load_versions(after=current_version)
            if not new_versions:
                LOGGER.info(f'Migration scripts after version {current_version} not found')
                return
            async with pool.acquire() as db:
                await execute_migration_scripts(db, new_versions)

    asyncio.run(_migrate_database())


@task(name='reset')
def reset_database(c):
    """
    Reset database
    """
    drop_database(c)
    create_database_if_not_exist(c)
    migrate_database(c)


def is_database_existed(c, env):
    r = c.run(f'''
        psql -h {c.db.host} -p {c.db.port} -U {c.db.owner.name} -lqt | cut -d \\| -f 1 | grep -w {c.db.database} | wc -l
        ''', hide='out', env=env)
    return 1 == int(r.stdout)


@task('lock-scripts')
def lock_scripts(c):
    """
    Lock migration scripts
    """
    for sql_path in SCRIPT_DIR.rglob('*.sql'):
        lock_path = sql_path.with_suffix('.locked')
        md_hash = calculate_md5_hash(sql_path)
        lock_path.write_text(md_hash)


@transactional
async def execute_migration_scripts(db: DBClient, versions: Dict[int, Path]):
    to_version = max(versions)
    LOGGER.info(f'Be about to migrate to {to_version}')
    from_version = min(versions)
    for version in range(from_version, to_version + 1):
        LOGGER.info(f'Applying version: {version}')
        await db.execute(versions[version].read_text(encoding='UTF-8'))
    await db.insert('database_migration', from_version=from_version, to_version=to_version,
                    migrated_at=dt.datetime.now(dt.timezone.utc))
    LOGGER.info(f'Migrated to {to_version}')


async def create_database_migration_table_if_not_exist(db: DBClient):
    await db.execute('''
        CREATE TABLE IF NOT EXISTS database_migration (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            from_version INT NOT NULL,
            to_version INT NOT NULL,
            migrated_at TIMESTAMP WITH TIME ZONE NOT NULL,
            
            CHECK (to_version >= from_version),
            EXCLUDE USING GIST (NUMRANGE(from_version, to_version, '[]') WITH &&)
        )
        ''')


db_tasks = Collection('db', create_database_if_not_exist, drop_database, reset_database, migrate_database,
                      lock_scripts)
db_tasks.configure({'db': {**settings.DB, 'owner': settings.DB_OWNER}})
